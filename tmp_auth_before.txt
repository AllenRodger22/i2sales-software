1	import React, { createContext, useState, ReactNode, useContext, useEffect, useCallback } from 'react';
2	import { useNavigate } from 'react-router-dom';
3	import { User, Role } from './types';
4	import { ApiError } from './services/apiClient';
5	import { supabase } from './src/lib/supabaseClient';
6	import * as authService from './services/auth'; // manter apenas para getMe()
7	import { ensureUser } from './services/users';
8	
9	type AuthState = 'loading' | 'authed' | 'guest';
10	
11	interface AuthContextType {
12	  token: string | null;
13	  user: User | null;
14	  login: (email: string, password: string) => Promise<void>;
15	  register: (name: string, email: string, password: string, role: Role) => Promise<{ confirmationSent: boolean }>;
16	  logout: () => Promise<void>;
17	  error: string | null;
18	  state: AuthState;
19	  sendPasswordResetEmail: (email: string) => Promise<void>;
20	  updatePassword: (password: string) => Promise<void>;
21	}
22	
23	export const AuthContext = createContext<AuthContextType | undefined>(undefined);
24	
25	export const useAuth = () => {
26	  const context = useContext(AuthContext);
27	  if (context === undefined) {
28	    throw new Error('useAuth must be used within an AuthProvider');
29	  }
30	  return context;
31	};
32	
33	const SITE_URL = (import.meta as any)?.env?.VITE_SITE_URL || window.location.origin;
34	
35	function mapAuthError(message?: string | null): string {
36	  const msg = (message || '').toLowerCase();
37	  if (msg.includes('invalid login credentials') || msg.includes('invalid email or password')) {
38	    return 'Email ou senha inválidos.';
39	  }
40	  if (msg.includes('user already registered') || msg.includes('already registered')) {
41	    return 'Um usuário com este e-mail já existe.';
42	  }
43	  if (msg.includes('password should be at least') || msg.includes('password is too weak')) {
44	    return 'Senha fraca: verifique a política de senha.';
45	  }
46	  if (msg.includes('email not confirmed')) {
47	    return 'Email não confirmado. Verifique sua caixa de entrada.';
48	  }
49	  return 'Ocorreu um erro. Tente novamente.';
50	}
51	
52	export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
53	  const [user, setUser] = useState<User | null>(null);
54	  const [token, setToken] = useState<string | null>(null);
55	  const [state, setState] = useState<AuthState>('loading');
56	  const [error, setError] = useState<string | null>(null);
57	  const navigate = useNavigate();
58	
59	  const fetchBackendUser = useCallback(async () => {
60	    try {
61	      const me = await authService.getMeFull();
62	      setUser(me.user);
63	      setState('authed');
64	      // Usa routing do backend quando disponível
65	      const rt = me?.routing?.target || '/app';
66	      const map: Record<string, string> = {
67	        '/admin': '/dashboard/admin',
68	        '/manager': '/dashboard/manager',
69	        '/app': '/dashboard/broker',
70	        '/onboarding': '/dashboard',
71	      };
72	      const target = map[rt] || '/dashboard';
73	      navigate(target, { replace: true });
74	    } catch (err) {
75	      console.warn('Falha ao carregar usuário do backend. Tentando fallback do Supabase...', err);
76	      // Tenta sempre o fallback via Supabase (mesmo em 401), para não travar navegação em dev
77	      try {
78	        const { data: { user: sUser } } = await supabase.auth.getUser();
79	        const meta: any = sUser?.user_metadata || {};
80	        const roleMeta = (meta.role || meta.requested_role || 'BROKER').toString().toUpperCase();
81	        const role = (roleMeta === 'ADMIN' || roleMeta === 'MANAGER' || roleMeta === 'BROKER') ? roleMeta : 'BROKER';
82	        if (sUser && sUser.email) {
83	          setUser({
84	            id: sUser.id,
85	            name: meta.name || (sUser.email.split('@')[0]),
86	            email: sUser.email,
87	            role: role as any,
88	          });
89	          setState('authed');
90	          navigate('/dashboard', { replace: true });
91	          return;
92	        }
93	      } catch (_) { /* ignore - handled below */ }
94	
95	      // Se não conseguir fallback, trata 401 com signOut; outros erros liberam UI como guest
96	      if (err instanceof ApiError && err.status === 401) {
97	        await supabase.auth.signOut();
98	        setUser(null);
99	        setToken(null);
100	        setState('guest');
101	        navigate('/login', { replace: true });
102	      } else {
103	        setError('Não foi possível carregar seu perfil.');
104	        setState('guest');
105	      }
106	    }
107	  }, [navigate]);
108	
109	  // Inicializa sessão do Supabase
110	  useEffect(() => {
111	    (async () => {
112	      const { data: { session } } = await supabase.auth.getSession();
113	      if (session) {
114	        setToken(session.access_token);
115	        await fetchBackendUser();
116	      } else {
117	        setState('guest');
118	      }
119	    })();
120	
121	    // Listener para mudanças na sessão (login/logout/refresh/password recovery)
122	    const { data: sub } = supabase.auth.onAuthStateChange(async (event, session) => {
123	      setToken(session?.access_token ?? null);
124	
125	      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
126	        setError(null);
127	        await fetchBackendUser();
128	      }
129	
130	      if (event === 'SIGNED_OUT') {
131	        setUser(null);
132	        setState('guest');
133	        navigate('/login', { replace: true });
134	      }
135	
136	      if (event === 'PASSWORD_RECOVERY') {
137	        // Link de recuperação chegou, redireciona para a página de mudança de senha
138	        navigate('/update-password', { replace: true });
139	      }
140	    });
141	
142	    return () => {
143	      sub.subscription.unsubscribe();
144	    };
145	  }, [fetchBackendUser, navigate]);
146	
147	  const login = async (email: string, password: string) => {
148	    setState('loading');
149	    setError(null);
150	    try {
151	      const { error } = await supabase.auth.signInWithPassword({ email, password });
152	      if (error) throw error;
153	      // Garante que o usuário exista no backend (ownerId = sub)
154	      const { data: { user: sUser } } = await supabase.auth.getUser();
155	      try {
156	        if (sUser?.email) {
157	          const meta: any = sUser.user_metadata || {};
158	          const roleMeta = (meta.role || meta.requested_role || 'BROKER').toString().toUpperCase();
159	          const r = (roleMeta === 'ADMIN' || roleMeta === 'MANAGER' || roleMeta === 'BROKER') ? roleMeta : 'BROKER';
160	          await ensureUser({ authId: sUser.id, ownerId: meta.sub || sUser.id, email: sUser.email, name: meta.name || (sUser.email.split('@')[0]), role: r as any });
161	        }
162	      } catch (_) { /* se falhar, seguimos com o fluxo; fetchBackendUser tenta novamente */ }
163	      // Sinaliza usuário provisório a partir do token (para redirecionar por role sem esperar /auth/me)
164	      const meta: any = sUser?.user_metadata || {};
165	      const roleMeta = (meta.role || meta.requested_role || 'BROKER').toString().toUpperCase();
166	      const role = (roleMeta === 'ADMIN' || roleMeta === 'MANAGER' || roleMeta === 'BROKER') ? roleMeta : 'BROKER';
167	      if (sUser && sUser.email) {
168	        const r = role as any;
169	        setUser({ id: sUser.id, name: meta.name || (sUser.email.split('@')[0]), email: sUser.email, role: r });
170	        setState('authed');
171	        // Redireciona imediatamente pela role do token
172	        const dest = r === 'ADMIN' ? '/dashboard/admin' : r === 'MANAGER' ? '/dashboard/manager' : '/dashboard/broker';
173	        navigate(dest, { replace: true });
174	      } else {
175	        // Sem user, segue para dashboard genérico; Redirector cuidará
176	        navigate('/dashboard', { replace: true });
177	      }
178	    } catch (err: any) {
179	      console.error('Login failed', err);
180	      setError(mapAuthError(err?.message));
181	      setState('guest');
182	      throw err;
183	    }
184	  };
185	
186	  const register = async (name: string, email: string, password: string, role: Role) => {
187	    setState('loading');
188	    setError(null);
189	    try {
190	      // Cadastro é no Supabase; backend só consome o access_token depois
191	      const { data, error } = await supabase.auth.signUp({
192	        email,
193	        password,
194	        options: {
195	          data: { name, requested_role: role, role },
196	          emailRedirectTo: SITE_URL,
197	        },
198	      });
199	      if (error) throw error;
200	
201	      const confirmationSent = !data.session; // se null, confirmação de email ativa
202	
203	      if (!confirmationSent) {
204	        // Usuário já autenticado; define user provisório e redireciona
205	        const sUser = data.user;
206	        const meta: any = sUser?.user_metadata || {};
207	        try {
208	          if (sUser?.email) {
209	            const roleMeta = (meta.role || meta.requested_role || 'BROKER').toString().toUpperCase();
210	            const r = (roleMeta === 'ADMIN' || roleMeta === 'MANAGER' || roleMeta === 'BROKER') ? roleMeta : 'BROKER';
211	            await ensureUser({ authId: sUser.id, ownerId: meta.sub || sUser.id, email: sUser.email, name: meta.name || (sUser.email.split('@')[0]), role: r as any });
212	          }
213	        } catch (_) { /* ignore */ }
214	        const roleMeta = (meta.role || meta.requested_role || 'BROKER').toString().toUpperCase();
215	        const r = (roleMeta === 'ADMIN' || roleMeta === 'MANAGER' || roleMeta === 'BROKER') ? roleMeta : 'BROKER';
216	        if (sUser && sUser.email) {
217	          setUser({ id: sUser.id, name: meta.name || (sUser.email.split('@')[0]), email: sUser.email, role: r as any });
218	          setState('authed');
219	        }
220	        navigate('/dashboard', { replace: true });
221	        // onAuthStateChange fará fetchBackendUser e ajustará rota final
222	      } else {
223	        setState('guest');
224	      }
225	      return { confirmationSent };
226	    } catch (err: any) {
227	      console.error('Registration failed', err);
228	      setError(mapAuthError(err?.message));
229	      setState('guest');
230	      throw err;
231	    }
232	  };
233	
234	  const sendPasswordResetEmail = async (email: string) => {
235	    setState('loading');
236	    setError(null);
237	    try {
238	      // Mesmo raciocínio do signup: não use '#/rota' aqui.
239	      // Após voltar para SITE_URL com o hash de tokens, o evento
240	      // 'PASSWORD_RECOVERY' do onAuthStateChange navega para '/update-password'.
241	      const { error } = await supabase.auth.resetPasswordForEmail(email, { redirectTo: SITE_URL });
242	      if (error) throw error;
243	    } catch (err: any) {
244	      console.error('Password reset failed', err);
245	      setError(mapAuthError(err?.message));
246	      throw err;
247	    } finally {
248	      setState('guest');
249	    }
250	  };
251	
252	  // Evitar troca prematura para 'guest' enquanto buscamos /api/me após login
253	  // Removido o timeout que forçava 'guest' em 1.5s para não causar bounce do RouteGuard
254	
255	  const updatePassword = async (password: string) => {
256	    setState('loading');
257	    setError(null);
258	    try {
259	      const { error } = await supabase.auth.updateUser({ password });
260	      if (error) throw error;
261	    } catch (err: any) {
262	      console.error('Password update failed', err);
263	      setError(mapAuthError(err?.message));
264	      throw err;
265	    } finally {
266	      setState('authed');
267	    }
268	  };
269	
270	  const logout = useCallback(async () => {
271	    setError(null);
272	    await supabase.auth.signOut(); // limpa LocalStorage e dispara SIGNED_OUT
273	    setUser(null);
274	    setToken(null);
275	    setState('guest');
276	    navigate('/login', { replace: true });
277	  }, [navigate]);
278	
279	  const value: AuthContextType = {
280	    token,
281	    user,
282	    login,
283	    register,
284	    logout,
285	    error,
286	    state,
287	    sendPasswordResetEmail,
288	    updatePassword,
289	  };
290	
291	  return (
292	    <AuthContext.Provider value={value}>
293	      {children}
294	    </AuthContext.Provider>
295	  );
296	};
297	
298	
299	
